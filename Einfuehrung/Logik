
import rclpy 
from rclpy.node import Node
from geometry_msgs.msg import Pose2D, Twist
import math
event= False
distance:float
angle_diff:float
postion_tolerance:float
angle_tolerance:float
linear_speed:float
position_tolerance: float = 0.3
angle_tolerance: float = 0.3
linear_speed: float = 0.4
angular_speed: float = 0.5
target_x:float
target_y:float
target_theta:float
linear_x=0.0
angular_z=0.0

def calculate_distance(self):
        """Berechnet Distanz zum Ziel"""
        dx = self.target_pose.x - self.current_pose.x
        dy = self.target_pose.y - self.current_pose.y
        return math.sqrt(dx**2 + dy**2)
def calculate_target_angle(self):
    """Berechnet den Zielwinkel zum gewÃ¼nschten Punkt"""
    dx = self.target_pose.x - self.current_pose.x
    dy = self.target_pose.y - self.current_pose.y
    return math.atan2(dy, dx)


def normalize_angle(self, angle):
        """Normalisiert Winkel auf [-pi, pi]"""
        while angle > math.pi:
            angle -= 2 * math.pi
        while angle < -math.pi:
            angle += 2 * math.pi
        return angle
def navigate_to_target(self,event,target_pose,current_pose):
        if event:
            distance = self.calculate_distance()
            arget_angle = self.calculate_target_angle()
            angle_diff = self.normalize_angle(target_angle - self.current_pose.theta)
        
            cmd = Twist()
        if distance > self.position_tolerance:
            if abs(angle_diff) > self.angle_tolerance:
                cmd.linear.x = 0.0
                cmd.angular.z = self.angular_speed if angle_diff > 0 else -self.angular_speed
            else:
                cmd.linear.x = self.linear_speed
                cmd.angular.z = 0.0
        else:
            cmd.linear.x = 0.0
            cmd.angular.z = 0.0
            print('Ziel erreicht!')
        self.cmd_publisher.publish(cmd) 
