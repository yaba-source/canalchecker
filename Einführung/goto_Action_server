import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Pose2D, Twist  # Twist statt twist
import math

class RobotTargetNavigation(Node):  # Klasse erbt von Node und folgt PEP8 Namenskonvention
    def __init__(self, zielposition, toleranz):
        super().__init__('robot_navigation')  # Node initialisieren
        self.target_pose = None
        self.current_pose = None  # current statt act
        self.toleranz = toleranz
        
        self.linear_speed = 0.4  # m/s
        self.angular_speed = 0.5  # rad/s
        self.position_tolerance = 0.1  # m
        self.angle_tolerance = 0.1  # rad

        self.pose_subscriber = self.create_subscription(
            Pose2D,
            '/robot_pose',
            self.pose_callback,
            10
        )
        
        self.target_subscriber = self.create_subscription(
            Pose2D,
            '/target_pose',
            self.target_callback,
            10
        )
            
        self.cmd_publisher = self.create_publisher(
            Twist,  # Twist statt twist
            '/cmd_vel',
            10
        )

    def pose_callback(self, msg):
        self.current_pose = msg
        
        if self.target_pose is not None and self.current_pose is not None:
            self.navigate_to_target()
        else:
            cmd = Twist()
            cmd.linear.x = 0.0
            cmd.angular.z = 0.0
            self.cmd_publisher.publish(cmd)
    
    def target_callback(self, msg):
        self.target_pose = msg
        print(f'Neue Zielpose: x={msg.x:.2f}, y={msg.y:.2f}, theta={math.degrees(msg.theta):.1f}°')

    def calculate_distance(self):
        """Berechnet Distanz zum Ziel"""
        dx = self.target_pose.x - self.current_pose.x
        dy = self.target_pose.y - self.current_pose.y
        return math.sqrt(dx**2 + dy**2)
    
    def calculate_target_angle(self):
        """Berechnet den Zielwinkel zum gewünschten Punkt"""
        dx = self.target_pose.x - self.current_pose.x
        dy = self.target_pose.y - self.current_pose.y
        return math.atan2(dy, dx)
    
    def normalize_angle(self, angle):
        """Normalisiert Winkel auf [-pi, pi]"""
        while angle > math.pi:
            angle -= 2 * math.pi
        while angle < -math.pi:
            angle += 2 * math.pi
        return angle
      
    def navigate_to_target(self):
        distance = self.calculate_distance()
        target_angle = self.calculate_target_angle()
        angle_diff = self.normalize_angle(target_angle - self.current_pose.theta)
        
        cmd = Twist()
        
        if distance > self.position_tolerance:
            if abs(angle_diff) > self.angle_tolerance:
                cmd.linear.x = 0.0
                cmd.angular.z = self.angular_speed if angle_diff > 0 else -self.angular_speed
            else:
                cmd.linear.x = self.linear_speed
                cmd.angular.z = 0.0
        else:
            # Wenn Position erreicht, drehe zum Zielwinkel
            if abs(angle_diff) > self.angle_tolerance:
                cmd.linear.x = 0.0
                cmd.angular.z = self.angular_speed if angle_diff > 0 else -self.angular_speed
            else:
                cmd.linear.x = 0.0
                cmd.angular.z = 0.0
        
        self.cmd_publisher.publish(cmd)